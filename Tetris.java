/*
PREAMBLE:
 
For my Robot of the Year submission, I have developed a simple but fully-functional game of Tetris to run within the robot maze environment. The game works inside the maze 
by treating walls and passages as two different colour pixels in a large grid, allowing for simple monochrome graphics to be generated by setting specific cells to 
walls/passages within the maze. The player is able to provide input using a JFrame from the javax.swing package, which listens for keyboard inputs while the window is 
selected. These two systems together act as the input/output interface between the player and game, which combined with the game logic implemented in this file form a 
playable game of Tetris.

In a game of Tetris, blocks called tetrominoes continually descend from the top of a grid, and slowly drop downwards, eventually locking in place when an obstruction is 
reached. The player can maneuverer the falling tetrominoes by moving them left and right, and rotating them clockwise and anti-clockwise, to position them precisely. The 
aim of the game is to fill complete rows with tiles, resulting in the row clearing and all tiles above dropping downwards. If the tetrominoes begin to stack too high, 
eventually new tetrominoes will have no room to fall, and the game is over. Points are accumulated for clearing rows, as well as manually dropping down tetrominoes, using 
soft-drops and hard-drops as explained below.

To play the game, this file should first be compiled, and then Tetris.class can be selected as the controller within the robot maze environment. By clicking ‘Begin’ a new 
game will start, and an input window will be opened. This input window MUST be selected, otherwise no keyboard input will be taken. The window is selected by default but 
can be reselected again by simply clicking within the input window.

The controls for the game are as follows:

Left Arrow key      -       Move left
Right Arrow key     -       Move right
X key               -       Rotate clockwise
Z key               -       Rotate anti-clockwise
Down Arrow key      -       Soft-drop (moves the tetromino one space downwards)
Space key           -       Hard-drop (fully drops the tetromino down until it becomes fixed)

The maze’s speed slider essentially acts as a difficulty slider for the game. I personally think a 0.5s delay is a nice speed to play with, just make sure the input window 
is reselected after adjusting the speed.

This game was a lot of fun to make, and has taught me a lot more about the intricacies of Java. It was interesting to make use of some of the topics covered in the lectures 
like enums and reflection which weren’t directly involved in the standard robot maze coursework. I hope you enjoy the game!
*/

import uk.ac.warwick.dcs.maze.logic.*;
import uk.ac.warwick.dcs.maze.gui.*;
import java.util.*;
import java.awt.Point;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import javax.swing.JFrame;
import java.lang.reflect.*;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Scanner;

public class Tetris {
    
    // Defines constants
    public final static int gridTileWidth = 10;
    public final static int gridTileHeight = 20;
    public final static int tileSize = 19;
    public final static int borderWidth = 8;
    public final static int UITileWidth = 8;
    public final static int titleRow = 1;
    public final static int gameOverRow = 3;
    public final static int scoreRow = 7;
    public final static int bestRow = 11;
    public final static int nextRow = 15;
    public final static int gridWidth = gridTileWidth * tileSize + (gridTileWidth - 1);
    public final static int gridHeight = gridTileHeight * tileSize + (gridTileHeight - 1);
    public final static int UIWidth = tileSize * UITileWidth;
    public final static int mazeWidth = 3 * borderWidth + gridWidth + UIWidth;
    public final static int mazeHeight = 2 * borderWidth + gridHeight;

    // Defines variables
    private JFrame frame;
    private Maze maze;
    private Grid grid;
    private Tetromino activeTetromino;
    private TetrominoType next;
    private int score;
    private int best;
    private boolean gameOver;
    private int step = 0;

    /**
     * Main method called at regular steps to advance the state of the game.
     * @param robot An IRobot object within the maze to use as the interface for the game.
     */
    public void controlRobot(IRobot robot) {
        if (step == 0) {
            initialiseGame(robot);
        }

        step++;

        playGame();
        updateDisplay();
    }

    /**
     * Performs necessary setup before the game begins, such as setting up the input window, creating the maze, drawing text, initialising 
     * variables and instantiating the first tetromino.
     * @param robot An IRobot object within the maze to use as the interface for the game.
     */
    public void initialiseGame(IRobot robot) {
        setupInputWindow();

        maze = setupMaze(robot);
        grid = new Grid(this);

        gameOver = false;
        score = 0;
        best = loadBestScore();

        initialiseUIText();

        activeTetromino = getNewTetromino();
    }

    /**
     * Controls general play of the game, such as creating new tetrominoes, checking for rows cleared and checking for game over.
     */
    public void playGame() {
        if (gameOver) {
            gameOverFlash();
        }
        else {

            // If the tetromino could successfully move down without a collision, perform row clear and game over checks.
            if (!activeTetromino.move(grid, 0, 1)) {
                grid.checkRowClear();

                // Get a new tetromino as long as the game is not yet over.
                if (grid.checkGameOver()) {
                    gameOver = true;
                    saveBestScore();
                    score = 0;
                    frame.dispose();
                }
                else {
                    activeTetromino = getNewTetromino();
                }
            }
        }
    }

    /**
     * Instantiates a new tetromino object to fall from the top-centre of the grid, randomly selecting the next one.
     * @return The newly instantiated tetromino object which is now active.
     */
    public Tetromino getNewTetromino() {

        // If it's the first tetromino, next has not yet been initialised, so assign it a random tetromino.
        if (next == null) {
            next = getRandomTetrominoType();
        }

        // Instantiate a new tetromino object at the top-centre of the grid, with its type dictated by what's stored as next.
        Tetromino tetromino = new Tetromino(next, new Point(gridTileWidth / 2 - 1, -1));

        // Get a random tetromino type for the next tetromino, and draw this in the UI panel.
        next = getRandomTetrominoType();
        drawNext();

        return tetromino;
    }

    /**
     * Opens a new JFrame window, which is used for input. When selected, the program can read keyboard presses to control tetrominoes as they fall.
     */
    public void setupInputWindow() {

        // Instantiate new window, setting its close operation, visibility and size, and be selected by default.
        frame = new JFrame("Input");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.requestFocus();
        frame.setVisible(true);
        frame.setSize(100,100);

        // Adds a listener for keyboard presses, calling the input method whenever a press occurs, passing the key code as an argument.
        frame.addKeyListener(new KeyAdapter() {
            public void keyPressed(KeyEvent e) {
                if (!gameOver)
                    input(e.getKeyCode());
            }
        });
    }

    /**
     * Gets and sets up the game's maze, changing its size and placing walls to create the initial grid borders.
     * @param robot An IRobot object within the maze to use as the interface for the game.
     * @return The newly set-up maze, ready to be used to play Tetris.
     */
    public Maze setupMaze(IRobot robot) {
        Maze robotMaze = robot.getMaze();

        // Uses reflection to get the maze's grid, a 2D array of its walls/passages, and overwites its value to an array of the desired size.
        try {
            Field grid = robotMaze.getClass().getDeclaredField("grid");
            grid.setAccessible(true);
            grid.set(robotMaze, new int[mazeWidth][mazeHeight]);
        }
        catch (Exception exception) {
            exception.printStackTrace();
        }

        // Iterates through each tile in the maze, determining whether it should be a wall or passage. Borders are drawn out surrounding the 
        // maze and separating the grid and UI areas, and dashed lines are drawn along each column and row in the grid.
        for (int x = 0; x < mazeWidth; x++) {
            for (int y = 0; y < mazeHeight; y++) {
                if (x < borderWidth || y < borderWidth || x >= mazeWidth-borderWidth || y >= mazeHeight-borderWidth)
                    robotMaze.setCellType(x, y, Maze.WALL);
                else if (x < mazeWidth - UIWidth - borderWidth && x >= borderWidth + gridWidth)
                    robotMaze.setCellType(x, y, Maze.WALL);
                else if (x < borderWidth + gridWidth && (x+y) % 4 == 0 && ((x - borderWidth + 1) % (tileSize + 1) == 0 || (y - borderWidth + 1) % (tileSize + 1) == 0))
                    robotMaze.setCellType(x, y, Maze.WALL);
                else
                    robotMaze.setCellType(x, y, Maze.PASSAGE);
            }
        }

        // Sets the target position to an arbitrary far-away point out of sight.
        robotMaze.setFinish(-999,-999);

        return robotMaze;
    }

    /**
     * Loads and returns the current best score stored within the best.txt file.
     * @return The best score, if one exists, otherwise a default best score of zero.
     */
    public int loadBestScore() {
        try {
            File file = new File("best.txt");

            // If the file exists, read the score and return it, otherwise return zero.
            if (file.createNewFile()) {
                return 0;
            } else {
                Scanner reader = new Scanner(file);
                return Integer.parseInt(reader.nextLine());
            }

        } catch (IOException e) {
            e.printStackTrace();
            return -1;
        }
    }

    /**
     * Saves the current best score to the best.txt file.
     */
    public void saveBestScore() {
        if (score > best) {
            try {

                // Creates a new file 'best.txt' or overwrites an old one to save the best score.
                FileWriter writer = new FileWriter("best.txt");
                writer.write(Integer.toString(score));
                writer.close();

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Generates a random type of tetromino.
     * @return A random tetromino type.
     */
    public TetrominoType getRandomTetrominoType() {
        return TetrominoType.values()[(int)(Math.random() * TetrominoType.values().length)];
    }

    /**
     * Controls result of player keyboard input, calling methods to move or rotate the currently falling tetromino in some way.
     * @param code The code of the key pressed by the player.
     */
    public void input(int code) {

        // Selects a different action depending on the key pressed.
        switch(code) {
            case KeyEvent.VK_RIGHT: // Moves the tetromino right.
                activeTetromino.move(grid, 1, 0);
                break;
            case KeyEvent.VK_LEFT: // Moves the tetromino left.
                activeTetromino.move(grid, -1, 0);
                break;
            case KeyEvent.VK_X: // Rotates the tetromino clockwise.
                activeTetromino.rotate(grid, 1);
                break;
            case KeyEvent.VK_Z: // Rotates the tetromino anti-clockwise.
                activeTetromino.rotate(grid, -1);
                break;
            case KeyEvent.VK_DOWN: // Soft-drop: Moves the tetromino downwards one tile.
                if (activeTetromino.move(grid, 0, 1))
                    // One point is awarded for each soft-drop.
                    addPoints(1);
                break;
            case KeyEvent.VK_SPACE: // Hard-drop: Continually drops the tetromino downwards until it is locked in place.
                while (activeTetromino.move(grid, 0, 1))
                    // Two points are awarded for every grid square dropped down during a hard-drop.
                    addPoints(2);
                break;
            default:
        }
        updateDisplay();
    }

    /**
     * Draws a specified tile (one of the four squares which make up a tetromino) into the maze by placing walls.
     * @param pos The co-ordinates at which the tile should be drawn.
     * @param tile The type of tetromino which the tile is part of, this dictates the style drawn.
     */
    public void drawTile(Point pos, TetrominoType tile) {

        for (int x = 0; x < Tetris.tileSize; x++) {
            for (int y = 0; y < Tetris.tileSize; y++) {
                boolean wall;
                if (tile == null)
                    wall = false;
                // Creates an empty gap of width 1 around the tile.
                else if (x <= 0 || y <= 0 || x >= Tetris.tileSize - 1 || y >= Tetris.tileSize - 1)
                    wall = false;
                // Creates a solid boundary of width 2 around the tile after the gap.
                else if (x <= 2 || y <= 2 || x >= Tetris.tileSize - 3 || y >= Tetris.tileSize - 3)
                    wall = true;
                else {
                    // Draws different patterns depending on the type of tile.
                    switch (tile) {
                        case I:
                            // Draws 2 perpendicular diagonal lines, creating a cross pattern.
                            if ((y > x-2 && y < x+2) || (Tetris.tileSize-y-1 > x-2 && Tetris.tileSize-y-1 < x+2))
                                wall = true;
                            else
                                wall = false;
                            break;
                        case O:
                            // Draws alternating walls and passages, creating the effect of a light grey shading.
                            if ((x + y) % 2 == 0)
                                wall = true;
                            else
                                wall = false;
                            break;
                        case T:
                            // Draws horizontal and vertical lines, creating a grid pattern.
                            if ((x-2) % 7 == 0 || (y-2) % 7 == 0)
                                wall = true;
                            else
                                wall = false;
                            break;
                        case J:
                            // Draws a series of parallel diagonal lines, creating a hashed pattern.
                            if (Math.abs(x - y) % 7 <= 1 || Math.abs(x - y) % 7 >= 6)
                                wall = true;
                            else
                                wall = false;
                            break;
                        case L:
                            // Draws a series of concentric squares.
                            if (x >= 8 && y >= 8 && x <= Tetris.tileSize - 9 && y <= Tetris.tileSize - 9)
                                wall = false;
                            else if (x >= 5 && y >= 5 && x <= Tetris.tileSize - 6 && y <= Tetris.tileSize - 6)
                                wall = true;
                            else
                                wall = false;
                            break;
                        case S:
                            // Draws a series of parallel diagonal lines, perpendicular to a second series of parallel diagonal lines, creating
                            // a diamond pattern.
                            if (Math.abs(x - y) % 6 == 0 || Math.abs(Tetris.tileSize - 1 + x + y) % 6 == 0)
                                wall = true;
                            else
                                wall = false;
                            break;
                        case Z:
                            // Draws nothing, creating an empty, white tile.
                            wall = false;
                            break;
                        default:
                            wall = false;
                    }
                }

                // Sets the corresponding cell in the maze to a wall/passage as calculated.
                maze.setCellType(pos.x + x, pos.y + y, wall ? Maze.WALL : Maze.PASSAGE);
                    
            }
        }
    }

    /*
     * Writes the initial text in the UI panel at the start of a new game.
     */
    public void initialiseUIText() {
        drawUIText(titleRow, "TETRIS");
        drawUIText(scoreRow, "SCORE");
        drawUIText(scoreRow+1, Integer.toString(score));
        drawUIText(bestRow, "BEST");
        drawUIText(bestRow+1, Integer.toString(best));
        drawUIText(nextRow, "NEXT");
    }

    /**
     * Writes text to the UI panel by converting characters to arrays of pixels and placing walls to draw character symbols.
     * @param row The row in the UI panel to write the text in, starting at zero at the top and incrementing down the screen.
     * @param text The text string to be written.
     */
    public void drawUIText(int row, String text) {

        // Initially clears the row of walls to fully overwrite any previous text without merging.
        for (int x = 0; x < UIWidth; x++) {
            for (int y = 0; y < tileSize; y++) {
                maze.setCellType(borderWidth * 2 + gridWidth + x, borderWidth + row * tileSize + y, Maze.PASSAGE);
            }
        }

        // Iterates through each character of the text string.
        for (int i = 0; i < text.length(); i++) {
            char character = text.charAt(i);
            for (int x = 0; x < Tetris.tileSize; x++) {
                for (int y = 0; y < Tetris.tileSize; y++) {
                    // Uses the CharacterSprite class to get each pixel within the character's symbol, and draws this to the screen.
                    boolean wall = CharacterSprite.getPixel(character, x, y);
                    maze.setCellType(borderWidth * 2 + gridWidth + UIWidth/2 - (text.length() * tileSize / 2) + i * tileSize + x, borderWidth + row * tileSize + y, wall ? Maze.WALL : Maze.PASSAGE);
                }
            }
        }
    }

    /**
     * Repeatedly draws and erases the 'GAME OVER' text to create a flashing effect.
     */
    public void gameOverFlash() {

        // If steps is even, clear the text, otherwise draw it.
        if (step % 2 == 0) {
            drawUIText(gameOverRow, "");
            drawUIText(gameOverRow+1, "");
        }
        else {
            drawUIText(gameOverRow, "GAME");
            drawUIText(gameOverRow+1, "OVER");
        }
    }

    /**
     * Draws the next tetromino's tiles in the UI panel under the 'next' heading.
     */
    public void drawNext() {

        // Initially clears the two rows of walls to fully overwrite the previous tetromino without merging.
        for (int x = 0; x < UIWidth; x++) {
            for (int y = 0; y < 2 * tileSize; y++) {
                maze.setCellType(borderWidth * 2 + gridWidth + x, borderWidth + (nextRow+2) * tileSize + y, Maze.PASSAGE);
            }
        }

        // Gets each tile of the tetromino using the getShapeForType method of the Tetromino class.
        Point[] shape = Tetromino.getShapeForType(next);

        // Calculates an offet to be added to each tile's x-position to keep both even and odd width tetrominoes centred.
        int tileOffset = (next == TetrominoType.I || next == TetrominoType.O) ? -tileSize : -(tileSize / 2);

        // Draws each tile in its position with the centre offset applied.
        for (int i = 0; i < shape.length; i++) {
            drawTile(new Point(borderWidth * 2 + gridWidth + UIWidth/2 + shape[i].x * tileSize + tileOffset, borderWidth + (nextRow + shape[i].y + 3) * tileSize) , next);
        }
    }

    /**
     * Adds a given number of new points to the score, writing it in the UI panel and updating the best score if necessary.
     * @param points The number of new points gained, to be added to the total score.
     */
    public void addPoints(int points) {

        // Adds the points to the score, checking the new score's digits can fit in its row when written in the UI panel.
        if (score + points > Math.pow(10, UITileWidth) - 1)
            score = (int) Math.pow(10, UITileWidth) - 1;
        else
            score += points;

        drawUIText(scoreRow + 1, Integer.toString(score));

        // Updates the best score if the current score has broken the record.
        if (score > best) {
            drawUIText(bestRow + 1, Integer.toString(score));
        }
    }

    /**
     * Forces an update of the maze's display by broadcasting a NEW_MAZE event.
     */
    public void updateDisplay() {
        Event e = new Event(IEvent.NEW_MAZE, maze);
        EventBus.broadcast(e);
    }

    /**
     * Sets step back to zero, saves the best score, and closes the input window when the reset button is clicked, ready for a new game.
     */
    public void reset() {
        step = 0;
        saveBestScore();
        frame.dispose();
    }

}

/**
 * Class to represent the grid system used in the game in which tetrominoes fall, distinct from the maze's grid.
 */
class Grid {

    private TetrominoType[][] grid;
    private Tetris game;

    /**
     * Instantiates a new grid object. 
     * @param game The Tetris game object which is to make use of the grid.
     */
    public Grid(Tetris game) {
        grid = new TetrominoType[Tetris.gridTileWidth][Tetris.gridTileHeight];
        this.game = game;
    }

    /**
     * Sets a tile within the grid to a certain tetromino type, and calls a method to draw this tile into the maze.
     * @param pos The grid co-ordinates at which the tile is to be set.
     * @param tile The type of tetromino tile to draw. Passing null for this argument clears all walls from the position specified.
     */
    public void setTile(Point pos, TetrominoType tile) {
        grid[pos.x][pos.y] = tile;
        game.drawTile(new Point(Tetris.borderWidth + (pos.x * (Tetris.tileSize + 1)), Tetris.borderWidth + (pos.y * (Tetris.tileSize + 1))), tile);
    }

    /**
     * Gets the tetromino type at a tile within the grid.
     * @param pos The grid co-ordinates of the tile to get.
     * @return The type of tetromino at the position specified. Null is returned if the position is empty.
     */
    public TetrominoType getTile(Point pos) {
        return grid[pos.x][pos.y];
    }

    /**
     * Checks for completely full rows within the grid, in which case these rows should be removed with all the above tiles moving down spaces
     * to fill the emptied rows. Points are added depending on the number of rows cleared in one move.
     */
    public void checkRowClear() {

        int rowsCleared = 0;

        // Iterates through each row starting from the top downwards.
        for (int y = 0; y < Tetris.gridTileHeight; y++) {

            // Initialises variable 'clear' to true, to later test if it remains true after checking each column.
            boolean clear = true;

            // Iterates through each column in the row.
            for (int x = 0; x < Tetris.gridTileWidth; x++) {

                // If an empty space is found, the row will certainly not be cleared, so 'clear' is set to false and the loop is broken.
                if (getTile(new Point(x, y)) == null) {
                    clear = false;
                    break;
                }
            }

            // If 'clear' is still true, the row is full, and should be cleared.
            if (clear) {
                rowsCleared++;

                // Iterates through each tile in the row, emptying each space.
                for (int x = 0; x < Tetris.gridTileWidth; x++) {
                    setTile(new Point(x, y), null);
                }

                // Iterates through each column for each row above the removed row, shifting the tile downwards a space.
                for (int y2 = y-1; y2 > 0; y2--) {
                    for (int x = 0; x < Tetris.gridTileWidth; x++) {
                        setTile(new Point(x, y2+1), getTile(new Point(x, y2)));
                        setTile(new Point(x, y2), null);
                    }
                }
            }
        }

        // Awards points based on the number of rows cleared in one move, with more points awarded for more rows cleared.
        switch (rowsCleared) {
            case 1:
                game.addPoints(100);
                break;
            case 2:
                game.addPoints(300);
                break;
            case 3:
                game.addPoints(500);
                break;
            case 4:
                game.addPoints(800);
            default: 
            // (No more than 4 rows can be cleared in one go).
        }
    }

    /**
     * Checks if the top-middle of the grid has been blocked by fixed tetrominoes, in which case the game is over.
     * @return A boolean value true if the game should be over and false otherwise.
     */
    public boolean checkGameOver() {
        return getTile(new Point(Tetris.gridTileWidth/2, 0)) != null || getTile(new Point(Tetris.gridTileWidth/2 - 1, 0)) != null;
    }
}

/** 
 * An enum for representing each of the seven different types of tetrominoes, named by capital letters they look similar to. 
*/
enum TetrominoType {I, O, T, J, L, S, Z}

/**
 * Class to represent the actively falling tetromino, which can be moved and rotated by the player.
 */
class Tetromino {

    public final static Point[][] iOffsetData =  {{new Point(0,0), new Point(-1,0), new Point(2,0), new Point(-1,0), new Point(2,0)},
                                                  {new Point(-1,0), new Point(0,0), new Point(0,0), new Point(0,-1), new Point(0,2)},
                                                  {new Point(-1,-1), new Point(1,-1), new Point(-2,-1), new Point(1,0), new Point(-2,0)},
                                                  {new Point(0,-1), new Point(0,-1), new Point(0,-1), new Point(0,1), new Point(0,-2)}};

    public final static Point[][] oOffsetData =  {{new Point(0,0)},
                                                  {new Point(0,1)},
                                                  {new Point(-1,1)},
                                                  {new Point(-1,0)}};

    public final static Point[][] otherOffsetData =  {{new Point(0,0), new Point(0,0), new Point(0,0), new Point(0,0), new Point(0,0)},
                                                      {new Point(0,0), new Point(1,0), new Point(1,1), new Point(0,-2), new Point(1,-2)},
                                                      {new Point(0,0), new Point(0,0), new Point(0,0), new Point(0,0), new Point(0,0)},
                                                      {new Point(0,0), new Point(-1,0), new Point(-1,1), new Point(0,-2), new Point(-1,-2)}};

    private TetrominoType type;
    private Point[] shape;

    // Variable 'rotation' is 0, 1, 2 or 3, corresponding to rotations of 0, 90, 180, and 270 degrees respectively.
    private int rotation;

    /**
     * Instantiates a new tetromino object of a certain type at the given position.
     * This constructor is used to create new tetrominoes to begin their fall from the top of the grid.
     * @param type The type of tetromino to create.
     * @param pos The grid co-ordinates at which the new tetromino is to be created.
     */
    public Tetromino(TetrominoType type, Point pos) {
        this.type = type;
        shape = getShapeForType(type);

        // Adds the given position to each point to move the tetromino to the correct position, whilst still preserving its shape.
        for (int i = 0; i < shape.length; i++) {
            shape[i].x += pos.x;
            shape[i].y += pos.y;
        }
        rotation = 0;
    }

    /**
     * Instantiates a new tetromino object of a certain type with a given shape.
     * This constructor is used to copy tetrominoes.
     * @param type The type of tetromino to create.
     * @param shape An array of points to define the new tetromino's shape.
     */
    public Tetromino(TetrominoType type, Point[] shape) {
        this.type = type;
        this.shape = shape;
        rotation = 0;
    }

    /**
     * Hides the tetromino by removing each of its tiles from the grid.
     * @param grid The grid object from which the tetromino should be removed.
     */
    public void hide(Grid grid) {
        for (int i = 0; i < shape.length; i++) {
            // Checks tiles have fallen into the grid to prevent index out of bounds errors.
            if (shape[i].y >= 0)
                grid.setTile(shape[i], null);
        }
    }

    /**
     * Shows the tetromino by setting each position's tile within the grid to the appropriate type.
     * @param grid The grid object to which the tetromino should be set into.
     */
    public void show(Grid grid) {
        for (int i = 0; i < shape.length; i++) {
            // Checks tiles have fallen into the grid to prevent index out of bounds errors.
            if (shape[i].y >= 0)
                grid.setTile(shape[i], type);
        }
    }

    /**
     * Moves the tetromino by a certain vector within the grid if possible, checking for collisions in the process.
     * @param grid The grid object in which the tetromino is falling through.
     * @param x The x-displacement to move the tetromino by.
     * @param y The y-displacement to move the tetromino by.
     * @return A boolean value true if the move was successful, false otherwise.
     */
    public boolean move(Grid grid, int x, int y) {

        hide(grid);
        boolean success = true;

        // For each tile within the tetromino, check if the new tile's position after moving would be within the maze and the space is empty.
        for (int i = 0; i < shape.length; i++) {
            if (!validatePosition(new Point(shape[i].x + x, shape[i].y + y), grid)) {
                success = false;
                break;
            }
        }

        // If the tetromino's new position would be valid, the move can go ahead. The given displacements are added to each tile's x and y
        // co-ordinates.
        if (success) {
            for (int i = 0; i < shape.length; i++) {
                shape[i].x += x;
                shape[i].y += y;
            }
        }

        show(grid);
        return success;
    }

    /**
     * Rotates the tetromino in a given direction about its centre, checking for collisions and applying offsets if necessary.
     * @param grid The grid object in which the tetromino is falling through.
     * @param dir The direction of rotation; a value of 1 performs a clockwise rotation, and -1 performs an anti-clockwise rotation.
     */
    public void rotate(Grid grid, int dir) {

        // Calculates what the new rotation of the block would be after the rotation.
        int newRotation = (rotation + dir + 4) % 4;

        hide(grid);

        // Copies the tetromino's shape to perform rotation and collision tests on, before applying to the actual tetromino.
        Point[] shapeCopy = copyShape();

        // Rotates each point in the tetromino by 90 degrees about its centre in the direction specified.
        for (int i = 0; i < shape.length; i++) {
            shapeCopy[i] = rotatePoint(shapeCopy[i], shapeCopy[0], dir);
        }

        // Checks for collisions and applies offsets if necessary until a suitable final position can be found.
        shapeCopy = offset(grid, shapeCopy, rotation, newRotation);

        // If a suitable position was found, the actual tetromino's shape can safely be updated. Otherwise the rotation fails.
        if (shapeCopy != null) {
            shape = shapeCopy;
            rotation = newRotation;
        }
        show(grid);
    }

    /*
     * Rotates a point 90 degrees about another pivot point in a given direction.
     */
    public Point rotatePoint(Point point, Point pivot, int dir) {

        // Calculates the position of the point to be rotated relative from its pivot point.
        Point relativePoint = new Point(point.x - pivot.x, point.y - pivot.y);

        // Swap co-ordinates and negate either the x or y to perform the rotation, adding back the pivot to find the final rotated point.
        return new Point((relativePoint.y * -dir) + pivot.x, (relativePoint.x * dir) + pivot.y);
    }

    /**
     * Applies a series of offset tests to a tetromino attempting to be rotated. Offsets are tried in a set order as defined in the tetromino
     * type's offset data, until a valid position is found. If no valid postion is found after trying all offsets, the rotation fails.
     * @param grid The grid object in which the tetromino is falling through.
     * @param shapeCopy A copy of the tetromino's points to attempt offset tests on.
     * @param prevRotation The current rotation of the tetromino (pre-rotation).
     * @param newRotation The new rotation of the tetromino (post-rotation).
     * @return The modified tetromino shape with its offset applied if successful, otherwise null is returned to indicate the rotation failed.
     */
    public Point[] offset(Grid grid, Point[] shapeCopy, int prevRotation, int newRotation) {
        
        Point[][] offsetData;

        // Fetches the offset data relevant to the tetromino's type. I and O tetrominoes have unique datasets, whilst other types share the same.
        switch (type) {
            case I:
                offsetData = iOffsetData;
                break;
            case O:
                offsetData = oOffsetData;
                break;
            default:
                offsetData = otherOffsetData;
        }

        // Iterates through each offset test. There are 5 offsets maximum which can be tried for all types, other than the O type which has only 1.
        for (int i = 0; i < offsetData[0].length; i++) {
            
            // Calculates the x and y offsets to attempt based on offsetData.
            int offetX = offsetData[prevRotation][i].x - offsetData[newRotation][i].x;
            int offsetY = offsetData[prevRotation][i].y - offsetData[newRotation][i].y;

            boolean validPlacement = true;

            // Check each tile of the tetromino to see if its offsetted position would be valid.
            for (int j = 0; j < shapeCopy.length; j++) {
                if (!validatePosition(new Point(shapeCopy[j].x + offetX, shapeCopy[j].y + offsetY), grid)) {
                    validPlacement = false;
                    break;
                }
            }

            // If an offset resulting in a valid tetromino position has been found, the offset can actually be applied and the modified shape
            // is returned.
            if (validPlacement) {
                for (int j = 0; j < shapeCopy.length; j++) {
                    shapeCopy[j].x += offetX;
                    shapeCopy[j].y += offsetY;
                }
                return shapeCopy;
            }
        }

        // If all offset tests failed, the rotation is not possible, so null is returned to reflect this.
        return null;
    }

    /**
     * Iterates over each point in the tetromino's shape to create a new array of these same points, making a deepy copy of the tetromino's shape.
     * @return An array of points, corresponding to the copy of the given tetromino's shape.
     */
    public Point[] copyShape() {
        Point[] shapeCopy = new Point[shape.length];
        for (int i = 0; i < shape.length; i++) {
            shapeCopy[i] = new Point(shape[i].x, shape[i].y);
        }
        return shapeCopy;
    }

    /**
     * Checks whether a given point is within the bounds of the grid (excluding the top) and is currently unoccupied by another tile.
     * @param point The point to be checked.
     * @param grid The grid within which the point is.
     * @return A boolean value true if the position is valid, and false otherwise.
     */
    private boolean validatePosition(Point point, Grid grid) {
        boolean valid = point.x >= 0 && point.x < Tetris.gridTileWidth && point.y < Tetris.gridTileHeight;

        // If the point is above the grid, this is still a valid position, but the empty tile check should be missed otherwise an error will occur.
        if (point.y >= 0)
            return valid && grid.getTile(point) == null;
        else 
            return valid;
    }

    /**
     * Gets an array of points representing the shape of a tetromino, given its type.
     * @param type The type of the tetromino to get the shape of.
     * @return An array of points, defining the shape of the tetronimo type.
     */
    public static Point[] getShapeForType(TetrominoType type) {
        switch (type) {
            case I:
                return new Point[]{new Point(0,0), new Point(-1,0), new Point(1,0), new Point(2,0)};
            case O:
                return new Point[]{new Point(0,0), new Point(1,-1), new Point(0,-1), new Point(1,0)};
            case T:
                return new Point[]{new Point(0,0), new Point(-1,0), new Point(1,0), new Point(0,-1)};
            case J:
                return new Point[]{new Point(0,0), new Point(-1,0), new Point(1,0), new Point(-1,-1)};
            case L:
                return new Point[]{new Point(0,0), new Point(-1,0), new Point(1,0), new Point(1,-1)};
            case S:
                return new Point[]{new Point(0,0), new Point(-1,0), new Point(0,-1), new Point(1,-1)};
            case Z:
                return new Point[]{new Point(0,0), new Point(0,-1), new Point(-1,-1), new Point(1,0)};
            default:
                return null;
        }
    }
}

/**
 * Class to store and access the pixels which make up the 19x19 character sprites, so text can be written into the maze.
 */
class CharacterSprite {

    public static final boolean[][] A =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, false, false},
        {false, false, false, false, false, true, true, true, true, true, true, true, true, false, false, false, false, false, false},
        {false, false, false, true, true, true, true, true, true, false, true, true, true, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, false, false, false, true, true, true, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, true, true, true, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, false, false, false, true, true, true, false, false, false, false, false, false},
        {false, false, false, true, true, true, true, true, true, false, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, false, true, true, true, true, true, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};
    
    
    public static final boolean[][] B =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, false, true, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, false, false},
        {false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, false, true, true, true, false, false, true, true, true, true, true, true, true, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};


    public static final boolean[][] C =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false},
        {false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, false, false, false, false, false, true, true, true, true, true, false, false},
        {false, false, false, true, true, true, true, false, false, false, false, false, true, true, true, true, false, false, false},
        {false, false, false, false, true, true, true, false, false, false, false, false, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};
    

    public static final boolean[][] E =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, true, true, true, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};


    public static final boolean[][] G =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false},
        {false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, true, true, true, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, true, true, true, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, true, true, true, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, false, true, true, true, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, true, false, false, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, true, true, true, true, false, false, true, true, true, true, true, true, true, false, false, false},
        {false, false, false, false, true, true, true, false, false, false, true, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};

    
    public static final boolean[][] I =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};

    public static final boolean[][] M =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};


       public static final boolean[][] N =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, true, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, true, true, true, true, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};


    public static final boolean[][] O =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false},
        {false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false},
        {false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};


    public static final boolean[][] R =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, false, true, true, true, true, true, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, false, true, true, true, true, true, false, false, true, true, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};


    public static final boolean[][] S =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, true, true, false, false, false, false, true, true, false, false, false, false},
        {false, false, false, true, true, true, true, true, true, true, false, false, false, true, true, true, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, true, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, true, false, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, true, true, true, false, false, false, true, true, true, true, true, true, true, false, false, false},
        {false, false, false, false, true, true, false, false, false, false, true, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};
    

    public static final boolean[][] T =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};


    public static final boolean[][] V =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};


    public static final boolean[][] X =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, false, false, false, false, false, true, true, true, true, true, false, false},
        {false, false, false, true, true, true, true, true, false, false, false, true, true, true, true, true, false, false, false},
        {false, false, false, false, true, true, true, true, true, false, true, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
        {false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, false, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
        {false, false, false, false, true, true, true, true, true, false, true, true, true, true, true, false, false, false, false},
        {false, false, false, true, true, true, true, true, false, false, false, true, true, true, true, true, false, false, false},
        {false, false, true, true, true, true, true, false, false, false, false, false, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};


    public static final boolean[][] ZERO =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false},
        {false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, true, true, true, true, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, true, true, true, true, true, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, true, true, true, true, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, false, false, false, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false},
        {false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};


    public static final boolean[][] ONE =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, true, true, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, false, true, true, true, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};
    

    public static final boolean[][] TWO =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, false, false, false, false, false, true, true, true, true, true, false, false},
        {false, false, false, true, true, true, true, false, false, false, false, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, false, false, false, false, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, false, false, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, true, true, true, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, true, true, true, true, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, true, true, true, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, true, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, true, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, false, false, false, false, true, true, true, false, false},
        {false, false, false, true, true, true, true, true, true, false, false, false, false, false, true, true, true, false, false},
        {false, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};


    public static final boolean[][] THREE =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, false, false, false, false, false, true, true, true, false, false, false, false},
        {false, false, false, true, true, true, true, false, false, false, false, false, true, true, true, true, false, false, false},
        {false, false, true, true, true, true, true, false, false, false, false, false, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, false, true, true, true, true, true, false, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, true, true, true, true, true, true, false, true, true, true, true, true, true, false, false, false},
        {false, false, false, false, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};

    
    public static final boolean[][] FOUR =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, true, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, true, true, true, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, false, true, true, true, true, false, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, true, false, false, true, true, true, false, false, false, false, false, false},
        {false, false, false, true, true, true, true, false, false, false, true, true, true, false, false, false, false, false, false},
        {false, false, true, true, true, true, false, false, false, false, true, true, true, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, false, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};


    public static final boolean[][] FIVE =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, true, true, true, true, true, true, true, false, false, false, true, true, false, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, false, false, true, true, true, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, true, true, true, true, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, true, false, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, false, true, true, true, true, true, true, true, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};


    public static final boolean[][] SIX =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false},
        {false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, true, true, true, true, false, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, true, true, true, true, false, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, false, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, true, true, true, false, false, false, true, true, true, true, true, true, true, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};
    
    
    public static final boolean[][] SEVEN =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, true, true, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, true, true, false, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, false, false, true, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, false, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, true, true, true, true, false, false, false, false},
        {false, false, true, true, true, false, false, true, true, true, true, true, true, false, false, false, false, false, false},
        {false, false, true, true, true, false, true, true, true, true, true, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, true, true, false, true, true, false, false, false, false, false, false, false, false, false},
        {false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};
    
    
    public static final boolean[][] EIGHT =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false},
        {false, false, false, true, true, true, true, true, true, false, true, true, true, true, true, true, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, true, true, true, true, true, false, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, false, true, true, true, true, true, false, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, true, true, true, true, true, true, false, true, true, true, true, true, true, false, false, false},
        {false, false, false, false, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};
    
    
    public static final boolean[][] NINE =
        {{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, true, true, true, true, true, true, true, false, false, false, true, true, true, false, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, true, false, true, true, true, true, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, false, false, false, true, true, true, false, false, false, true, true, true, false, false},
        {false, false, true, true, true, true, false, true, true, true, true, false, false, true, true, true, true, false, false},
        {false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false},
        {false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false},
        {false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
        {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}};

    /**
     * Determines whether a wall or passage should be set for a certain character sprite at a given position.
     * @param c The character who's sprite should be used.
     * @param x The x co-ordinate of the pixel's position.
     * @param y The y co-ordinate of the pixel's position.
     * @return
     */
    public static boolean getPixel(char c, int x, int y) {
        switch (c) {
            case 'A':
                return A[x][y];
            case 'B':
                return B[x][y];
            case 'C':
                return C[x][y];
            case 'E':
                return E[x][y];
            case 'G':
                return G[x][y];
            case 'I':
                return I[x][y];
            case 'M':
                return M[x][y];
            case 'N':
                return N[x][y];
            case 'O':
                return O[x][y];
            case 'R':
                return R[x][y];
            case 'S':
                return S[x][y];
            case 'T':
                return T[x][y];
            case 'V':
                return V[x][y];
            case 'X':
                return X[x][y];
            case '0':
                return ZERO[x][y];
            case '1':
                return ONE[x][y];
            case '2':
                return TWO[x][y];
            case '3':
                return THREE[x][y];
            case '4':
                return FOUR[x][y];
            case '5':
                return FIVE[x][y];
            case '6':
                return SIX[x][y];
            case '7':
                return SEVEN[x][y];
            case '8':
                return EIGHT[x][y];
            case '9':
                return NINE[x][y];
            default:
                return false;
        }
    }
}